# ComfyUI Model Resolver v2.0 - ä»»åŠ¡åˆ†è§£æ–‡æ¡£

## æ¶æ„è®¾è®¡

åŸºäº **FastAPI + Gradio** æ¶æ„ï¼Œå®ç°å‰åç«¯åˆ†ç¦»ï¼Œä¾¿äºåç»­åŠŸèƒ½è¿­ä»£ã€‚

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     HTTP/WebSocket    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Gradio Client  â”‚ â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º â”‚  FastAPI Server â”‚
â”‚   (Frontend)    â”‚                       â”‚   (Backend API)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                                    â”‚
                                          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                                          â”‚   Core Modules    â”‚
                                          â”‚  (å·²å®Œæˆçš„è„šæœ¬)   â”‚
                                          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Phase 1: API å±‚è®¾è®¡ä¸å®ç°ï¼ˆ3å¤©ï¼‰

### Task 1.1: FastAPI é¡¹ç›®ç»“æ„æ­å»ºï¼ˆ0.5å¤©ï¼‰

**ç›®æ ‡**ï¼šåˆ›å»ºæ ‡å‡†çš„ FastAPI é¡¹ç›®ç»“æ„

```
project/
â”œâ”€â”€ api/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ main.py              # FastAPI ä¸»åº”ç”¨
â”‚   â”œâ”€â”€ routers/             # API è·¯ç”±
â”‚   â”‚   â”œâ”€â”€ workflow.py      # å·¥ä½œæµç›¸å…³API
â”‚   â”‚   â”œâ”€â”€ search.py        # æœç´¢ç›¸å…³API
â”‚   â”‚   â”œâ”€â”€ download.py      # ä¸‹è½½ç›¸å…³API
â”‚   â”‚   â””â”€â”€ config.py        # é…ç½®ç›¸å…³API
â”‚   â”œâ”€â”€ models/              # Pydantic æ•°æ®æ¨¡å‹
â”‚   â”‚   â”œâ”€â”€ workflow.py
â”‚   â”‚   â”œâ”€â”€ search.py
â”‚   â”‚   â””â”€â”€ download.py
â”‚   â”œâ”€â”€ services/            # ä¸šåŠ¡é€»è¾‘å±‚
â”‚   â”‚   â”œâ”€â”€ workflow_service.py
â”‚   â”‚   â”œâ”€â”€ search_service.py
â”‚   â”‚   â””â”€â”€ download_service.py
â”‚   â””â”€â”€ utils/               # å·¥å…·å‡½æ•°
â”œâ”€â”€ core/                    # ç°æœ‰æ ¸å¿ƒæ¨¡å—ï¼ˆå¤ç”¨ï¼‰
â”‚   â”œâ”€â”€ workflow_analyzer_v3.py
â”‚   â”œâ”€â”€ multi_platform_searcher.py
â”‚   â””â”€â”€ optimized_search.py
â”œâ”€â”€ frontend/                # Gradio å‰ç«¯
â”‚   â””â”€â”€ app.py
â””â”€â”€ data/                    # æ•°æ®å­˜å‚¨
    â””â”€â”€ resolver_data.json
```

### Task 1.2: API æ•°æ®æ¨¡å‹å®šä¹‰ï¼ˆ0.5å¤©ï¼‰

**ç›®æ ‡**ï¼šä½¿ç”¨ Pydantic å®šä¹‰æ‰€æœ‰ API æ•°æ®æ¨¡å‹

```python
# api/models/workflow.py
from pydantic import BaseModel
from typing import List, Optional, Dict
from datetime import datetime

class WorkflowModel(BaseModel):
    """å·¥ä½œæµæ¨¡å‹"""
    path: str
    name: str
    status: str  # "ready", "partial", "missing", "unanalyzed"
    total_models: int
    missing_count: int
    last_analyzed: Optional[datetime]

class ModelInfo(BaseModel):
    """æ¨¡å‹ä¿¡æ¯"""
    filename: str
    model_type: str
    exists_locally: bool
    size: Optional[int]
    local_path: Optional[str]
    selected: bool = False  # æ˜¯å¦é€‰ä¸­

class AnalyzeRequest(BaseModel):
    """åˆ†æè¯·æ±‚"""
    workflow_paths: List[str]

class AnalyzeResponse(BaseModel):
    """åˆ†æå“åº”"""
    workflows: List[WorkflowModel]
    models: List[ModelInfo]

class SearchRequest(BaseModel):
    """æœç´¢è¯·æ±‚"""
    models: List[str]
    platforms: List[str] = ["huggingface", "civitai"]

class SearchResult(BaseModel):
    """æœç´¢ç»“æœ"""
    filename: str
    sources: List[Dict]  # åŒ…å« url, platform, rating, name
    selected_source: Optional[str]
    custom_url: Optional[str]
```

### Task 1.3: å·¥ä½œæµ API å®ç°ï¼ˆ1å¤©ï¼‰

**ç›®æ ‡**ï¼šå®ç°å·¥ä½œæµç›¸å…³çš„æ‰€æœ‰ API ç«¯ç‚¹

```python
# api/routers/workflow.py
from fastapi import APIRouter, HTTPException, Query
from typing import List, Optional
import os

router = APIRouter(prefix="/api/workflow", tags=["workflow"])

@router.get("/list")
async def list_workflows(directory: str = Query(..., description="å·¥ä½œæµç›®å½•è·¯å¾„")):
    """
    åˆ—å‡ºç›®å½•ä¸‹çš„æ‰€æœ‰å·¥ä½œæµ
    è¿”å›æ ¼å¼ï¼š
    [
        {
            "path": "/path/to/workflow.json",
            "name": "workflow.json",
            "status": "partial",
            "total_models": 8,
            "missing_count": 2,
            "last_analyzed": "2024-01-14T10:30:00"
        }
    ]
    """
    # è°ƒç”¨ service å±‚
    
@router.post("/analyze")
async def analyze_workflows(request: AnalyzeRequest):
    """
    åˆ†æå·¥ä½œæµï¼Œè¿”å›æ¨¡å‹åˆ—è¡¨
    """
    # è°ƒç”¨ workflow_analyzer_v3.py
    
@router.get("/status/{workflow_id}")
async def get_workflow_status(workflow_id: str):
    """
    è·å–å•ä¸ªå·¥ä½œæµçš„è¯¦ç»†çŠ¶æ€
    """
    # ä» JSON å­˜å‚¨è¯»å–

@router.post("/export-script")
async def export_download_script(workflow_paths: List[str]):
    """
    å¯¼å‡ºä¸‹è½½è„šæœ¬
    """
    # ç”Ÿæˆ bash è„šæœ¬
```

### Task 1.4: æœç´¢ API å®ç°ï¼ˆ1å¤©ï¼‰

**ç›®æ ‡**ï¼šå®ç°æ¨¡å‹æœç´¢ç›¸å…³çš„ API

```python
# api/routers/search.py
from fastapi import APIRouter, BackgroundTasks

router = APIRouter(prefix="/api/search", tags=["search"])

@router.post("/models")
async def search_models(request: SearchRequest):
    """
    æœç´¢æ¨¡å‹ï¼Œè¿”å›æ¯ä¸ªæ¨¡å‹çš„å¤šä¸ªä¸‹è½½æº
    """
    # è°ƒç”¨ multi_platform_searcher.py
    
@router.post("/validate-url")
async def validate_custom_url(url: str):
    """
    éªŒè¯è‡ªå®šä¹‰URLçš„æœ‰æ•ˆæ€§
    è¿”å›ï¼š{valid: bool, size: int, filename: str}
    """
    # å‘é€ HEAD è¯·æ±‚éªŒè¯

@router.get("/cached-results/{model_hash}")
async def get_cached_results(model_hash: str):
    """
    è·å–ç¼“å­˜çš„æœç´¢ç»“æœ
    """
```

## Phase 2: ä¸šåŠ¡é€»è¾‘å±‚å°è£…ï¼ˆ2å¤©ï¼‰

### Task 2.1: å·¥ä½œæµæœåŠ¡å±‚ï¼ˆ0.5å¤©ï¼‰

**ç›®æ ‡**ï¼šå°è£…å·¥ä½œæµåˆ†æçš„ä¸šåŠ¡é€»è¾‘

```python
# api/services/workflow_service.py
from core.workflow_analyzer_v3 import WorkflowAnalyzerV3
from typing import List, Dict
import json
import os

class WorkflowService:
    def __init__(self):
        self.analyzer = WorkflowAnalyzerV3()
        self.data_file = "data/resolver_data.json"
        self._init_data_file()
    
    def scan_directory(self, directory: str) -> List[Dict]:
        """æ‰«æç›®å½•è·å–å·¥ä½œæµåˆ—è¡¨"""
        workflows = []
        for file in os.listdir(directory):
            if file.endswith('.json'):
                filepath = os.path.join(directory, file)
                status = self._get_workflow_status(filepath)
                workflows.append({
                    "path": filepath,
                    "name": file,
                    "status": status['status'],
                    "total_models": status['total_models'],
                    "missing_count": status['missing_count'],
                    "last_analyzed": status.get('last_analyzed')
                })
        return workflows
    
    def analyze_workflow(self, workflow_path: str) -> Dict:
        """åˆ†æå•ä¸ªå·¥ä½œæµ"""
        # è°ƒç”¨ç°æœ‰çš„ analyzer
        result = self.analyzer.analyze(workflow_path)
        
        # æ£€æŸ¥æœ¬åœ°æ–‡ä»¶
        models_with_status = self._check_local_models(result['models'])
        
        # ä¿å­˜ç»“æœ
        self._save_analysis_result(workflow_path, models_with_status)
        
        return {
            "workflow": workflow_path,
            "models": models_with_status
        }
    
    def _check_local_models(self, models: List[Dict]) -> List[Dict]:
        """æ£€æŸ¥æ¨¡å‹çš„æœ¬åœ°å­˜åœ¨çŠ¶æ€"""
        # å¤ç”¨ check_local_models å‡½æ•°
        pass
```

### Task 2.2: æœç´¢æœåŠ¡å±‚ï¼ˆ0.5å¤©ï¼‰

**ç›®æ ‡**ï¼šå°è£…æ¨¡å‹æœç´¢é€»è¾‘

```python
# api/services/search_service.py
from core.multi_platform_searcher import MultiPlatformSearcher
from core.optimized_search import OptimizedModelSearcher
import os
import asyncio

class SearchService:
    def __init__(self):
        self.searcher = MultiPlatformSearcher(
            civitai_token=os.getenv('CIVITAI_API_KEY')
        )
        self.optimizer = OptimizedModelSearcher()
    
    async def search_models(self, models: List[Dict]) -> Dict:
        """æ‰¹é‡æœç´¢æ¨¡å‹"""
        results = {}
        
        # å¹¶å‘æœç´¢
        tasks = []
        for model in models:
            task = self._search_single_model(model)
            tasks.append(task)
        
        search_results = await asyncio.gather(*tasks)
        
        # ç»„ç»‡ç»“æœ
        for model, result in zip(models, search_results):
            results[model['filename']] = {
                'sources': result['sources'],
                'recommended': result['sources'][0] if result['sources'] else None
            }
        
        return results
    
    async def _search_single_model(self, model: Dict) -> Dict:
        """æœç´¢å•ä¸ªæ¨¡å‹"""
        # è°ƒç”¨ç°æœ‰æœç´¢é€»è¾‘
        results = await self.searcher.search(
            model['filename'],
            model_type=model.get('model_type')
        )
        
        # æ·»åŠ è¯„åˆ†
        for source in results:
            source['rating'] = self._calculate_rating(source)
        
        # æ’åº
        results.sort(key=lambda x: x['rating'], reverse=True)
        
        return {'sources': results}
```

### Task 2.3: ä¸‹è½½æœåŠ¡å±‚ï¼ˆ1å¤©ï¼‰

**ç›®æ ‡**ï¼šå®ç°ä¸‹è½½é˜Ÿåˆ—ç®¡ç†

```python
# api/services/download_service.py
import asyncio
from typing import Dict, List, Optional
import aiohttp
import aiofiles
import os
from datetime import datetime

class DownloadService:
    def __init__(self):
        self.download_queue = asyncio.Queue()
        self.active_downloads = {}
        self.completed_downloads = []
        self.is_running = False
        
    async def start_worker(self):
        """å¯åŠ¨ä¸‹è½½å·¥ä½œçº¿ç¨‹"""
        self.is_running = True
        while self.is_running:
            try:
                task = await asyncio.wait_for(
                    self.download_queue.get(), 
                    timeout=1.0
                )
                await self._process_download(task)
            except asyncio.TimeoutError:
                continue
    
    async def add_to_queue(self, download_task: Dict):
        """æ·»åŠ åˆ°ä¸‹è½½é˜Ÿåˆ—"""
        task_id = f"{download_task['filename']}_{datetime.now().timestamp()}"
        download_task['id'] = task_id
        download_task['status'] = 'queued'
        
        await self.download_queue.put(download_task)
        return task_id
    
    async def get_status(self) -> Dict:
        """è·å–ä¸‹è½½çŠ¶æ€"""
        return {
            "queue_size": self.download_queue.qsize(),
            "active": list(self.active_downloads.values()),
            "completed": self.completed_downloads[-10:]  # æœ€è¿‘10ä¸ª
        }
    
    async def _process_download(self, task: Dict):
        """å¤„ç†å•ä¸ªä¸‹è½½ä»»åŠ¡"""
        task_id = task['id']
        self.active_downloads[task_id] = {
            'filename': task['filename'],
            'progress': 0,
            'speed': 0,
            'status': 'downloading'
        }
        
        try:
            await self._download_file(
                task['url'],
                task['target_path'],
                task_id
            )
            
            self.completed_downloads.append({
                'filename': task['filename'],
                'status': 'success',
                'completed_at': datetime.now().isoformat()
            })
        except Exception as e:
            self.completed_downloads.append({
                'filename': task['filename'],
                'status': 'failed',
                'error': str(e),
                'completed_at': datetime.now().isoformat()
            })
        finally:
            del self.active_downloads[task_id]
```

## Phase 3: Gradio å‰ç«¯å¼€å‘ï¼ˆ3å¤©ï¼‰

### Task 3.1: API å®¢æˆ·ç«¯å°è£…ï¼ˆ0.5å¤©ï¼‰

**ç›®æ ‡**ï¼šåˆ›å»ºä¸åç«¯ API é€šä¿¡çš„å®¢æˆ·ç«¯

```python
# frontend/api_client.py
import httpx
from typing import List, Dict, Optional
import asyncio

class APIClient:
    def __init__(self, base_url="http://localhost:8000"):
        self.base_url = base_url
        self.client = httpx.AsyncClient(timeout=30.0)
    
    async def list_workflows(self, directory: str) -> List[Dict]:
        """è·å–å·¥ä½œæµåˆ—è¡¨"""
        response = await self.client.get(
            f"{self.base_url}/api/workflow/list",
            params={"directory": directory}
        )
        response.raise_for_status()
        return response.json()
    
    async def analyze_workflows(self, paths: List[str]) -> Dict:
        """åˆ†æå·¥ä½œæµ"""
        response = await self.client.post(
            f"{self.base_url}/api/workflow/analyze",
            json={"workflow_paths": paths}
        )
        response.raise_for_status()
        return response.json()
    
    async def search_models(self, models: List[str]) -> Dict:
        """æœç´¢æ¨¡å‹"""
        response = await self.client.post(
            f"{self.base_url}/api/search/models",
            json={"models": models}
        )
        response.raise_for_status()
        return response.json()
    
    async def add_download(self, download_info: Dict) -> str:
        """æ·»åŠ ä¸‹è½½ä»»åŠ¡"""
        response = await self.client.post(
            f"{self.base_url}/api/download/add",
            json=download_info
        )
        response.raise_for_status()
        return response.json()['task_id']
```

### Task 3.2: Gradio ç•Œé¢ç»„ä»¶ï¼ˆ1å¤©ï¼‰

**ç›®æ ‡**ï¼šå®ç°ä¸‰ä¸ªä¸»è¦æ ‡ç­¾é¡µ

```python
# frontend/components.py
import gradio as gr
from typing import List, Dict, Callable
import asyncio

class WorkflowAnalyzerUI:
    def __init__(self, api_client):
        self.api_client = api_client
        self.current_directory = "/workspace/ComfyUI/workflows"
        self.workflow_data = {}
        self.model_data = {}
        
    def create_workflow_tab(self):
        """åˆ›å»ºå·¥ä½œæµåˆ†ææ ‡ç­¾é¡µ"""
        with gr.Tab("å·¥ä½œæµåˆ†æ"):
            # ç›®å½•é€‰æ‹©
            with gr.Row():
                directory_input = gr.Textbox(
                    value=self.current_directory,
                    label="å·¥ä½œæµç›®å½•",
                    scale=4
                )
                refresh_btn = gr.Button("ğŸ”„åˆ·æ–°", scale=1)
            
            # å·¥ä½œæµåˆ—è¡¨
            workflow_checklist = gr.CheckboxGroup(
                label="é€‰æ‹©å·¥ä½œæµ",
                choices=[],
                value=[]
            )
            
            # æ‰¹é‡æ“ä½œ
            with gr.Row():
                select_all_btn = gr.Button("å…¨é€‰", size="sm")
                select_none_btn = gr.Button("å…¨ä¸é€‰", size="sm")
                analyze_btn = gr.Button("åˆ†æé€‰ä¸­çš„å·¥ä½œæµ", variant="primary")
                export_script_btn = gr.Button("å¯¼å‡ºæ‰¹é‡ä¸‹è½½è„šæœ¬")
            
            # åˆ†éš”çº¿
            gr.Markdown("---")
            
            # å½“å‰å·¥ä½œæµè¯¦æƒ…
            workflow_info = gr.Markdown("è¯·é€‰æ‹©å·¥ä½œæµæŸ¥çœ‹è¯¦æƒ…")
            
            # æ¨¡å‹åˆ—è¡¨
            model_checklist = gr.CheckboxGroup(
                label="æ¨¡å‹åˆ—è¡¨",
                choices=[],
                value=[]
            )
            
            # æ¨¡å‹æ“ä½œ
            with gr.Row():
                select_missing_btn = gr.Button("ä»…é€‰ç¼ºå¤±", size="sm")
                search_btn = gr.Button("æœç´¢é€‰ä¸­çš„æ¨¡å‹", variant="primary")
                export_model_script_btn = gr.Button("å¯¼å‡ºä¸‹è½½è„šæœ¬")
            
            # æ—¥å¿—
            log_output = gr.Textbox(
                label="æ“ä½œæ—¥å¿—",
                lines=5,
                max_lines=10,
                autoscroll=True
            )
            
            # äº‹ä»¶ç»‘å®š
            refresh_btn.click(
                fn=self.refresh_workflows,
                inputs=[directory_input],
                outputs=[workflow_checklist, log_output]
            )
            
            analyze_btn.click(
                fn=self.analyze_selected_workflows,
                inputs=[workflow_checklist],
                outputs=[model_checklist, workflow_info, log_output]
            )
            
            return {
                'directory_input': directory_input,
                'workflow_checklist': workflow_checklist,
                'model_checklist': model_checklist,
                'log_output': log_output
            }
```

### Task 3.3: å‰ç«¯ä¸»åº”ç”¨ï¼ˆ1å¤©ï¼‰

**ç›®æ ‡**ï¼šæ•´åˆæ‰€æœ‰ç»„ä»¶ï¼Œåˆ›å»ºå®Œæ•´åº”ç”¨

```python
# frontend/app.py
import gradio as gr
import asyncio
from api_client import APIClient
from components import WorkflowAnalyzerUI, SearchResultUI, DownloadManagerUI

class ModelResolverApp:
    def __init__(self):
        self.api_client = APIClient()
        self.workflow_ui = WorkflowAnalyzerUI(self.api_client)
        self.search_ui = SearchResultUI(self.api_client)
        self.download_ui = DownloadManagerUI(self.api_client)
        
    def create_interface(self):
        """åˆ›å»ºå®Œæ•´çš„ Gradio ç•Œé¢"""
        with gr.Blocks(
            title="ComfyUI Model Resolver v2.0",
            theme=gr.themes.Soft()
        ) as app:
            # æ ‡é¢˜
            gr.Markdown("# ComfyUI Model Resolver v2.0")
            
            # é¡¶éƒ¨å·¥å…·æ 
            with gr.Row():
                with gr.Column(scale=4):
                    gr.Markdown("æ™ºèƒ½åˆ†æå’Œä¸‹è½½ ComfyUI å·¥ä½œæµæ‰€éœ€çš„æ¨¡å‹")
                with gr.Column(scale=1):
                    settings_btn = gr.Button("è®¾ç½®", size="sm")
                    help_btn = gr.Button("å¸®åŠ©", size="sm")
            
            # ä¸»æ ‡ç­¾é¡µ
            with gr.Tabs() as main_tabs:
                # å·¥ä½œæµåˆ†ææ ‡ç­¾
                workflow_components = self.workflow_ui.create_workflow_tab()
                
                # æœç´¢ç»“æœæ ‡ç­¾
                search_components = self.search_ui.create_search_tab()
                
                # ä¸‹è½½ç®¡ç†æ ‡ç­¾
                download_components = self.download_ui.create_download_tab()
            
            # è®¾ç½®å¼¹çª—
            with gr.Group(visible=False) as settings_modal:
                self.create_settings_modal()
            
            # äº‹ä»¶å¤„ç†
            self.setup_event_handlers(
                workflow_components,
                search_components,
                download_components,
                settings_btn,
                settings_modal
            )
        
        return app
    
    def setup_event_handlers(self, workflow, search, download, settings_btn, settings_modal):
        """è®¾ç½®æ‰€æœ‰äº‹ä»¶å¤„ç†å™¨"""
        # æ ‡ç­¾é¡µåˆ‡æ¢æ•°æ®ä¼ é€’
        workflow['search_btn'].click(
            fn=lambda x: gr.Tabs.update(selected=1),
            outputs=[main_tabs]
        )
        
        # è®¾ç½®å¼¹çª—
        settings_btn.click(
            fn=lambda: gr.Group.update(visible=True),
            outputs=[settings_modal]
        )

if __name__ == "__main__":
    app = ModelResolverApp()
    interface = app.create_interface()
    
    # å¯åŠ¨åº”ç”¨
    interface.launch(
        server_name="0.0.0.0",
        server_port=7860,
        share=False,
        inbrowser=True
    )
```

### Task 3.4: WebSocket å®æ—¶æ›´æ–°ï¼ˆ0.5å¤©ï¼‰

**ç›®æ ‡**ï¼šå®ç°ä¸‹è½½è¿›åº¦çš„å®æ—¶æ›´æ–°

```python
# frontend/websocket_handler.py
import asyncio
import json
from typing import Callable
import websockets

class WebSocketHandler:
    def __init__(self, ws_url="ws://localhost:8000/ws"):
        self.ws_url = ws_url
        self.callbacks = {}
        
    async def connect_progress_updates(self, callback: Callable):
        """è¿æ¥ WebSocket è·å–è¿›åº¦æ›´æ–°"""
        async with websockets.connect(f"{self.ws_url}/download-progress") as websocket:
            while True:
                try:
                    message = await websocket.recv()
                    data = json.loads(message)
                    
                    if data['type'] == 'progress':
                        await callback(data['data'])
                    elif data['type'] == 'completed':
                        await callback(data['data'])
                        
                except websockets.exceptions.ConnectionClosed:
                    break
                except Exception as e:
                    print(f"WebSocket error: {e}")
                    await asyncio.sleep(1)
```

## Phase 4: é›†æˆä¸ä¼˜åŒ–ï¼ˆ2å¤©ï¼‰

### Task 4.1: Docker é…ç½®ï¼ˆ0.5å¤©ï¼‰

**ç›®æ ‡**ï¼šåˆ›å»ºå®¹å™¨åŒ–éƒ¨ç½²æ–¹æ¡ˆ

```dockerfile
# Dockerfile
FROM python:3.10-slim

WORKDIR /app

# å®‰è£…ç³»ç»Ÿä¾èµ–
RUN apt-get update && apt-get install -y \
    wget \
    git \
    && rm -rf /var/lib/apt/lists/*

# å¤åˆ¶ä¾èµ–æ–‡ä»¶
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# å¤åˆ¶åº”ç”¨ä»£ç 
COPY api/ ./api/
COPY core/ ./core/
COPY frontend/ ./frontend/
COPY data/ ./data/

# å¤åˆ¶å¯åŠ¨è„šæœ¬
COPY start.sh .
RUN chmod +x start.sh

# æš´éœ²ç«¯å£
EXPOSE 8000 7860

# å¯åŠ¨å‘½ä»¤
CMD ["./start.sh"]
```

```bash
# start.sh
#!/bin/bash

# å¯åŠ¨ FastAPI åç«¯
echo "Starting FastAPI backend..."
uvicorn api.main:app --host 0.0.0.0 --port 8000 --reload &

# ç­‰å¾…åç«¯å¯åŠ¨
echo "Waiting for backend to start..."
sleep 5

# æ£€æŸ¥åç«¯æ˜¯å¦å¯åŠ¨æˆåŠŸ
curl -f http://localhost:8000/health || exit 1

# å¯åŠ¨ Gradio å‰ç«¯
echo "Starting Gradio frontend..."
python frontend/app.py
```

### Task 4.2: å•å…ƒæµ‹è¯•ï¼ˆ0.5å¤©ï¼‰

**ç›®æ ‡**ï¼šç¼–å†™å…³é”®åŠŸèƒ½çš„å•å…ƒæµ‹è¯•

```python
# tests/test_workflow_api.py
import pytest
from httpx import AsyncClient
from api.main import app

@pytest.mark.asyncio
async def test_list_workflows():
    """æµ‹è¯•å·¥ä½œæµåˆ—è¡¨ API"""
    async with AsyncClient(app=app, base_url="http://test") as client:
        response = await client.get(
            "/api/workflow/list",
            params={"directory": "/test/workflows"}
        )
        assert response.status_code == 200
        assert isinstance(response.json(), list)

@pytest.mark.asyncio
async def test_analyze_workflow():
    """æµ‹è¯•å·¥ä½œæµåˆ†æ API"""
    async with AsyncClient(app=app, base_url="http://test") as client:
        response = await client.post(
            "/api/workflow/analyze",
            json={"workflow_paths": ["/test/workflow.json"]}
        )
        assert response.status_code == 200
        data = response.json()
        assert "models" in data
```

### Task 4.3: æ€§èƒ½ä¼˜åŒ–ï¼ˆ0.5å¤©ï¼‰

**ç›®æ ‡**ï¼šä¼˜åŒ–å…³é”®è·¯å¾„æ€§èƒ½

1. **API å“åº”ç¼“å­˜**
```python
from fastapi_cache import FastAPICache
from fastapi_cache.decorator import cache

@router.get("/workflow/list")
@cache(expire=60)  # ç¼“å­˜60ç§’
async def list_workflows(directory: str):
    # ...
```

2. **æ‰¹é‡æ“ä½œä¼˜åŒ–**
```python
# ä½¿ç”¨ asyncio.gather å¹¶å‘å¤„ç†
async def batch_analyze(workflows: List[str]):
    tasks = [analyze_single(w) for w in workflows]
    results = await asyncio.gather(*tasks)
    return results
```

3. **æ•°æ®åº“è¿æ¥æ± **ï¼ˆå¦‚æœåç»­ä½¿ç”¨æ•°æ®åº“ï¼‰

### Task 4.4: éƒ¨ç½²æ–‡æ¡£ï¼ˆ0.5å¤©ï¼‰

**ç›®æ ‡**ï¼šç¼–å†™å®Œæ•´çš„éƒ¨ç½²å’Œä½¿ç”¨æ–‡æ¡£

```markdown
# éƒ¨ç½²æŒ‡å—

## å¿«é€Ÿå¼€å§‹

### Docker éƒ¨ç½²ï¼ˆæ¨èï¼‰
```bash
docker build -t comfyui-resolver:v2.0 .
docker run -p 7860:7860 -p 8000:8000 \
  -v /workspace:/workspace \
  comfyui-resolver:v2.0
```

### æ‰‹åŠ¨éƒ¨ç½²
```bash
# 1. å®‰è£…ä¾èµ–
pip install -r requirements.txt

# 2. è®¾ç½®ç¯å¢ƒå˜é‡
export CIVITAI_API_KEY=your_key
export HF_TOKEN=your_token

# 3. å¯åŠ¨æœåŠ¡
./start.sh
```

## API æ–‡æ¡£
è®¿é—® http://localhost:8000/docs æŸ¥çœ‹è‡ªåŠ¨ç”Ÿæˆçš„ API æ–‡æ¡£

## é…ç½®è¯´æ˜
...
```

## æ—¶é—´çº¿æ±‡æ€»

| é˜¶æ®µ | ä»»åŠ¡ | é¢„è®¡æ—¶é—´ | å…³é”®äº¤ä»˜ç‰© |
|------|------|----------|-----------|
| Phase 1 | APIå±‚è®¾è®¡ä¸å®ç° | 3å¤© | RESTful API, WebSocket |
| Phase 2 | ä¸šåŠ¡é€»è¾‘å±‚å°è£… | 2å¤© | Serviceå±‚, å¤ç”¨ç°æœ‰ä»£ç  |
| Phase 3 | Gradioå‰ç«¯å¼€å‘ | 3å¤© | å®Œæ•´UI, å®æ—¶æ›´æ–° |
| Phase 4 | é›†æˆä¸ä¼˜åŒ– | 2å¤© | Dockeré•œåƒ, æ–‡æ¡£ |
| **æ€»è®¡** | | **10å¤©** | |

## å…³é”®æŠ€æœ¯å†³ç­–

### ä¸ºä»€ä¹ˆé€‰æ‹© FastAPI + Gradioï¼Ÿ

1. **FastAPI ä¼˜åŠ¿**ï¼š
   - è‡ªåŠ¨ç”Ÿæˆ API æ–‡æ¡£
   - åŸç”Ÿå¼‚æ­¥æ”¯æŒ
   - WebSocket æ”¯æŒ
   - ç±»å‹å®‰å…¨

2. **å‰åç«¯åˆ†ç¦»ä¼˜åŠ¿**ï¼š
   - ä¾¿äºåç»­æ›¿æ¢å‰ç«¯ï¼ˆå¦‚æ”¹ä¸º Vue/Reactï¼‰
   - æ”¯æŒå¤šå®¢æˆ·ç«¯ï¼ˆCLIã€Webã€æ’ä»¶ï¼‰
   - API å¯ç‹¬ç«‹æµ‹è¯•å’Œéƒ¨ç½²
   - æ›´å¥½çš„æ‰©å±•æ€§

3. **å¤ç”¨ç°æœ‰ä»£ç **ï¼š
   - æ ¸å¿ƒé€»è¾‘ä¸éœ€è¦é‡å†™
   - åªéœ€è¦å°è£…ä¸º Service å±‚
   - é™ä½å¼€å‘é£é™©

## é£é™©æ§åˆ¶

1. **Gradio é™åˆ¶**ï¼š
   - æŸäº›å¤æ‚äº¤äº’å¯èƒ½éœ€è¦å¦¥å
   - è§£å†³æ–¹æ¡ˆï¼šä½¿ç”¨ gr.HTML è‡ªå®šä¹‰ç»„ä»¶

2. **æ€§èƒ½é—®é¢˜**ï¼š
   - å¤§é‡æ¨¡å‹æœç´¢å¯èƒ½è¾ƒæ…¢
   - è§£å†³æ–¹æ¡ˆï¼šå¼‚æ­¥å¤„ç† + è¿›åº¦åé¦ˆ

3. **ç½‘ç»œé—®é¢˜**ï¼š
   - ä¸‹è½½å¯èƒ½ä¸­æ–­
   - è§£å†³æ–¹æ¡ˆï¼šæ–­ç‚¹ç»­ä¼  + é‡è¯•æœºåˆ¶